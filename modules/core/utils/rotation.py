#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Dec  2 17:21:42 2019

@author: greg
"""

def check_4_rotation(chan_list,inv):
	"""
	The following function is checking if the channels from the 
	input channels list is good to be used for rotation. 
	1> The number of channel in the list must be = 3
	3> The network, station dans location must be the same
	4> Channels must be ??U, ..V, ??W
	5> Starttime, Endtime, sampling and number of points must be the same
	----
	INPUT:
		@chan_list: list of channels to be rotated
		@inv	  : inventory object to get dip and azimuth for each channels
	----
	OUPUT:
		@rot_chan_list: list of rotated channels
		
	"""
	rot_chan_list = None
	if len(chan_list) == 3:
		# Check for validity of the data
		station_l = [cha.stats.station for cha in chan_list]
		network_l = [cha.stats.network for cha in chan_list]
		location_l = [cha.stats.location for cha in chan_list]
		channel_l = [cha.stats.channel for cha in chan_list]
		if len(set(network_l)) != 1 \
			or len(set(station_l)) !=1 or len(set(location_l)) !=1:
			print("Network, station or location are not the same for all channels.")
			
			return None
		else:
			axes = [orient[2] for orient in channel_l]
			axes.sort()
			if (axes == ['U', 'V', 'W']):
				print("On peut appliquer la rotation")
				
			else:
				print("It's not UVW channels")
				return None
	else:
		print("There is no exactly 3 channels...")
		return None
	
	
def rotate_func_NEZ(cha_list, inventory):
	
	"""
	Function which realize the rotation from UVW to ZNE.
	In this function, time series are supposed to be perfectly aligned
	with the same starttime, the same endtime and the same sampling rate.
	If the channels in cha_list are not aligned, one can try to use the function 
	'sync_trim_channels' which try to find the common part of thoses time series 
	between a given startime of trim and an endtime of trim
	
	----
	INPUT
		@channel_list : list of 3 channels supposed to be U,V and W 
		@inv		  : Inventory object generated by OBSPY from the dataless
	----
	OUTPUT:
		@rotated_channel : list of 3 channels
	
	"""
	from obspy import Stream
	from obspy.signal.rotate import rotate2zne
	import sys
	from calibration import get_dip_azimuth
	

	if len(cha_list)!=3:
		sys.exit("ERROR : The number of channels must be equal to 3 to apply the rotation.")
	
	channel2rotate = cha_list.copy()

	rot_param = {}
	for cha in channel2rotate:
		dip_azi = get_dip_azimuth(inventory,cha.stats.station, \
				cha.stats.location, \
				cha.stats.channel)

		rot_param[cha.stats.channel[2]] = {}
		rot_param[cha.stats.channel[2]]["alpha"] = float(dip_azi.get("dip"))
		rot_param[cha.stats.channel[2]]["beta"] = float(dip_azi.get("azimuth"))
		rot_param[cha.stats.channel[2]]["channel"] = cha.stats.channel

	for cha in channel2rotate:
		if cha.stats.channel[2] == "U": 
			alpha_U = rot_param["U"]["alpha"]
			beta_U = rot_param["U"]["beta"]
			tr_N = cha.copy()
			tr_N.stats.channel = cha.stats.channel[:2]+"N"
			
		if cha.stats.channel[2] == "V":
			alpha_V = rot_param["V"]["alpha"]
			beta_V = rot_param["V"]["beta"]
			tr_E = cha.copy()
			tr_E.stats.channel = cha.stats.channel[:2]+"E"
				
		if cha.stats.channel[2] == "W":
			alpha_W = rot_param["W"]["alpha"]
			beta_W = rot_param["W"]["beta"]
			tr_Z = cha.copy()
			tr_Z.stats.channel = cha.stats.channel[:2]+"Z"
	
	Z, N, E = rotate2zne(tr_N.data, beta_U, alpha_U,  
						 tr_E.data, beta_V, alpha_V, 
						 tr_Z.data, beta_W, alpha_W)
	
	tr_N._internal_add_processing_info("::ASPIC: Rotation from UVW to NEZ.")
	tr_E._internal_add_processing_info("::ASPIC: Rotation from UVW to NEZ.")
	tr_Z._internal_add_processing_info("::ASPIC: Rotation from UVW to NEZ.")
	
	rotated_stream = Stream([tr_N, tr_E, tr_Z])
	return rotated_stream
	
